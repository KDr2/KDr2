# -*- mode: org; mode: auto-fill -*-
#+TITLE: 扯淡：开发相关
#+AUTHOR: KDr2

# #+OPTIONS: toc:nil
#+OPTIONS: num:nil

#+BEGIN: inc-file :file "common.inc.org"
#+END:
#+CALL: dynamic-header() :results raw
#+CALL: meta-keywords(kws='("扯淡" "开发")) :results raw

<2014-10-31 Fri>

# ----
#+BEGIN: inc-file :file "gad.inc.org"
#+END:


新工作一个多月，形形色色的工作都接触了一些，又回想起之前几份工作，觉得
挺有意思，就随便扯了扯记了记。话题分的没什么逻辑性，想到哪儿就说到哪儿。

* 乱七八糟的话题
** 侧重 Performance 还是侧重 Maintainability？

   相比起 Maintainability 的度量来说，Performance 的度量可能更容易做的
   客观一些，可以用一些简洁有力的数据给出佐证。而由于团队成员的知识结构
   与水平的不同，Maintainability 则会成岭成峰人各不同。

   简单举例：
   对于一个多表的联合查询，有的人会觉得一个 Join 语句简洁明快，
   而另外一些人则会觉得这连来连去的好负责，还不如我流水帐般先查主表然后
   循环查其它表条理更清楚（典型 1+n 查询）。
   相关的例子还有，放着数据库内建支持的 Trigger 不用，在应用层使用 ORM
   的 Listener 来做 Trigger 该做的事情。

   从 Maintainability 角度看，双方观点大相径庭，但是从 Performance 角
   度看，尤其在具体的场景下，孰优孰劣会一目了然。

   另一个例子：
   之前有份工作中要设计一种 DSL 来描述某些数据的某些或某类集合，以及判
   定这些数据是否属于某个集合，一开始我简单的利用编程语言的语法特定来
   做了一下，大概如此： ~Q(user).age.gt(18)~, 对于简单的集合还算一目了
   然，但是对于复杂的（多种数据类型之间又有若干关系），写起来还可以，读
   起来就得定定神，大家觉得劳神费力，我却觉得简单明了还有编程语言给你做
   语法检查，DSL 的实现复杂度也不是很高，挺好。后来在大家的呼吁下，我又
   对这个 DSL 重新做了设计和实现，用 flex 和 bison 做了 Parser，然后实现
   了个微型的 interpreter。当然之前版本的 Performance 不高也是选择重新实
   现的一个原因。果然新的 DSL 读着写着都神清气爽，Native 的实现也使
    Performance 有了大幅提升，大家都很高兴。但
   是这却带来了另外一个问题：这个 DSL 的实现本身的 Maintainability 对于团
   队来说又怎样呢？ 团队中有人说的也有道理：无论怎么实现，愿维护能维护的
   都是那几个人。

   我提出这个问题不是说我在完全否定其中的某一种开发方式，使用“侧重”这
   个词，本身就明确表达了这不是一个非黑即白的问题。我想表达的只是一个
   疑问： *在一个团队中，衡量 Maintainability 的标准应该如何制定呢？*

** 你如何对待自己在技术上的偏好？

   每个人都有自己的喜好与厌恶，无人成为例外。

   # 我承认我的好恶，同时，我不以此为荣，也不以此为耻。但是无法避免的
   # 是，它们明显的左右着我的避与趋。

   跟我在工作上稍微打过交道的人都知道，我喜欢后端相关开发而厌恶前端开
   发，而且我从来不加掩饰。因为，要把事情做好，需要两样东西： *能力*
   和 *意愿* 。如果我两样都没有却强加掩饰，换来的是什么呢？

   但是，工作就是工作，如果它需要你顶上的时候，该如何做呢？

   当然，退出是一种快捷的选择。如果没有选择退出的话，那你必须在能力与
   意愿两个方面做出调节。

   值得庆幸得是，意愿如同心情一样，你可以在需要得时候想方设法调上去，
   不需要得时候迅速现出原形。而不幸的是，能力这个看上去会是一直积累的
   东西却不一定像我们所想的那样形成积累：在生物进化论中被证明是错误的
   用进废退理论在个人能力上却是无比正确的，意愿消失，能力搁置，不久便
   会退化。

   蛇蜕皮会成长，人蜕皮却不会成长，因为他没有成长的意愿。

   从个人角度讲，这也许是你选择一份工作的代价。

** 代码英雄模式还是流水线模式？
  
  互联网行业流行一个词，“快糙猛”。
  
  天下武功，唯快不破。快不仅是说你开发速度要快，更是强调了代码的
  Performance 要高。在此基础上，不必处处追求完美，不要让完美主义束缚了
  你前进的脚步，糙一下又何妨？最后一个猛，对 Performance 做再一次的强
  调，也表达出开发者所要拿出的当仁不让的气势。

  在这样的思想的指导下，每个团队都有那么几个超人，几个人搞定大部分技术
  难点，搞出一套基础设施，之后众人一呼而上，大部分应用层的问题在此之上
  迎刃而解。这种模式对于小型公司尤其有效。

  但这不是做软件工程的所追求的方式。软件工程追求开发者的可替代性，追求
  流水线式的开发模式。

  如果说用机器制造机器标志着工业革命的完成，那让从培训流水线上出来的开
  发者去软件开发流水线上出色的完成开发工作，那肯定标志着软件开发行业一
  项伟大革命的完成――比让软件开发软件还要伟大――如果某天软件能自己开发软
  件，那肯定是某个个人或小团体靠他们的个人英雄主义搞出来的。

** 什么样的开发者才是 Full-Stack 的？

   #   也许我说那些会自称 Full-Stack Developer 的人往往都是只会一些 Web 相
   #   关技术（他们眼中的前端和后端）并且还不一定在这些领域做的很好的人，
   #   也许得罪一众人，但是，我还是在这里说了出来。

   且先不论那么多的纵向领域，只看最普通的 Web 应用开发，简单列举一下跟
   其相关的 Stack 层次：

   - ……^{集成电路}
   - 处理器，存储设备等硬件
   - 操作系统以及与体系结构相关的工具链
   - 各种中间件
   - 业务逻辑应用层
   - 用户界面（实现与设计又可以分两个层次）
   - ……^{用户}

   你的 Stack Full 了么？
  
   当然，你的 Stack 是不是 Full 甚至 Overflow 了，这不是我要说的。我想
   说的是：

   - 对于开发者个体，无论你选择哪（几）个层次，你必须要做到非常了解跟
     它们相邻的（至少前后各一个）层次，唯有如此才能保证产出的质量。
   - 对于开发团队整体，你必须承认其中各个个体之间的知识结构和水平是不
     相同的，就连同一批培训学校出来的学员也不会是均一的。
   - 接到前面的话题上，让团队成员蜕皮（皮质估计也好不了），不如让他们长肉。

* 我到底想说什么？
  
  其实我只有一句词：
  
  *N nights I kept typing, 我扯下这许多淡……*

# ----
#+BEGIN: inc-file :file "gad.inc.org"
#+END:

* Discuss and Comment
  #+BEGIN: inc-file :file "disqus.inc.org"
  #+END:

